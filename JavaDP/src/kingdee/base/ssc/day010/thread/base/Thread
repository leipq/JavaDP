锁
    互斥性
    可重入性

共享对象
    可见性

非原子的64位操作
    当一个线程在没有同步的情况下读取变量，他可能会得到一个过期值，但是至少它可以看到某个线程在那里设置的一个真实数据，而不是凭空而来的数据；
    这样的安全保证被称为 最低限的安全性

    最低限的安全性应用于所有的变量，除了一个例外：没有声明为 volatile 的64位数值变量 （double和 long）。

    Java存储模型要求获取和存储操作都为原子的，但是对于非 volatile 的 long 和 double变量，JVM允许将64位的读或者写划分为两个 32位的操作。
    如果读和写发生在不同的线程，这种情况读取一个非volatile 类型 long 就可能得到一个值的高32位和另一个值的低32位。因此，即使不关心过期数据，
    但仅仅在多线程程序中使用共享的，可变的long 和 double 变量也可能是不安全的，除非他们声明为 volatile 类型，或者用锁保护起来。

    锁不仅仅是关于同步与互斥的，也是关于内存可见的。为了保证所有线程都能够看到共享的，可变变量的最新值，读取和写入线程必须使用公共的锁进行同步。

Volatile变量
    禁止重排序

    加锁可以保证可见性和原子性；volatile变量只能保证可见性
    只有满足一下的所有标准后，才能使用volatile变量
        1写入变量时不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
        2变量不需要与其他状态变量共同参与不变约束
        3访问变量时，没有其他的原因需要加锁

