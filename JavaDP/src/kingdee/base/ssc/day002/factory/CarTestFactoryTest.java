package kingdee.base.ssc.day002.factory;

import org.junit.Test;
/**
 * 定义：
 *         工厂模式是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
 *         工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。
 *
 * 工厂模式根据抽象程度的不同分为三种：
    * 简单工厂模式（也叫静态工厂模式）
    * 工厂方法模式（也叫多形性工厂）
    * 抽象工厂模式（也叫工具箱）
 *
 * 简单工厂模式
 *         实质是由一个工厂类根据传入的参数，
 *         动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。
 *         简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。
 *
 * 工厂方法模式
 *         工厂方法是粒度很小的设计模式，因为模式的表现只是一个抽象的方法。
 *         提前定义用于创建对象的接口，让子类决定实例化具体的某一个类，
 *         即在工厂和产品中间增加接口，工厂不再负责产品的创建，
 *         由接口针对不同条件返回具体的类实例，由具体类实例去实现。
 *
 * 抽象工厂模式
 *         当有多个抽象角色时使用的一种工厂模式。
 *         抽象工厂模式可以向客户端提供一个接口，
 *         使客户端在不必指定产品的具体的情况下，
 *         创建多个产品对象。它有多个抽象产品类，
 *         每个抽象产品类可以派生出多个具体产品类，
 *         一个抽象工厂类，可以派生出多个具体工厂类，
 *         每个具体工厂类可以创建多个具体产品类的实例。
 *
 * 工厂模式的优点：
*         1、一个调用者想创建一个对象，只要知道其名称就可以了，降低了耦合度。
*         2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。使得代码结构更加清晰。
*         3、屏蔽产品的具体实现，调用者只关心产品的接口。
*
*         工厂模式的缺点：
*         每次增加一个产品时，
*         都需要增加一个具体类和对象实现工厂（这里可以使用反射机制来避免），
*         使得系统中类的个数成倍增加，
*         在一定程度上增加了系统的复杂度，
*         同时也增加了系统具体类的依赖。
*         所以对于简单对象来说，
*         使用工厂模式反而增加了复杂度。
 */



public class CarTestFactoryTest {
    @Test
    public void test() {
        ICarFactory factory = null;
        // bike
        factory = new BikeFactory();
        Car bike = factory.getCar();
        bike.gotowork();

        // bus
        factory = new BusFactory();
        Car bus = factory.getCar();
        bus.gotowork();
    }
}
